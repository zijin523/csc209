#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

// NOTE: MAX_PASSWORD must be less than  MAXLINE/2
#define MAXLINE 32
#define MAX_PASSWORD 10  

#define PASSWORD_FILE "pass.txt"

/* Reads two chunks from stdin, and checks if they match a user id
 * and password pair from a password file. The first chunk (MAX_PASSWORD bytes)
 * will contain a user id, and the second chunk (MAX_PASSWORD bytes) will 
 * contain a password.
 * 
 * The program exits with a value of 
 *      0 if the user id and password match,
 *      1 if there is an error, 
 *      2 if the user id is found but the password does not match, and 
 *      3 if the user id is not found in the password file. 
 */


/* Note that read will read at most MAX_PASSWORD bytes. This means that the
 * longest password we can support is MAX_PASSWORD.  We can't count on the
 * caller to send the null termination character, so we have to ensure
 * that we terminate the string that is sent anyway.
 *
 * If the input is coming from the console/keyboard, then the write calls
 * are managed by the shell which will process each piece of input 
 * separately.
 * However, if the input is coming from a pipe, there is no guarantee that
 * two writes generated by checkpasswd will send the data such that it
 * will be read by the two reads below.  The means that it is important for
 * checkpasswd to send exactly as many bytes that validate is expecting.
 * Otherwise the behaviour may be unpredicatable.
 *
 * This also means that checkpasswd should report an invalid password
 * or no user_id if the user input is longer than MAX_PASSWORD.
 */

int main() {
    int r1 = fork();
    if (r1 == 0) {
        r1 = fork();
        if (r1 == 0) {
            exit(0);
        }
    }

    int sum = 0;
    while (wait(NULL) != -1) {
        sum++;
    }
    fprintf(stderr, "Waited for %d processes", sum);
    return 0;
}